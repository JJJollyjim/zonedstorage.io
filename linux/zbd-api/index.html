<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Linux Zoned Storage Documentation">
    
    <link rel="canonical" href="https://zonedstorage.io/linux/zbd-api/">
    <link rel="shortcut icon" href="../../img/favicon.ico">

    
    <title>User Interface - Zoned Storage</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../../css/base.min.css" rel="stylesheet">
    <link href="../../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/github.min.css">
        
    

    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-D23L5EBB2E"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-D23L5EBB2E');
    </script>
    

     
</head>

<body style="padding-top:90px" >

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            <a class="navbar-brand" href="../..">Zoned Storage</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../..">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="../../community/">Community</a>
                    </li>
                
                
                
                    <li class="dropdown active" style="min-height:60;">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
  
  
  
  <li class="dropdown-submenu">
    <a tabindex="-1" href="/introduction/">Introduction</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../introduction/zoned-storage/">Zoned Storage Overview</a>
</li>

        
            
<li >
    <a href="../../introduction/smr/">Shingled Magnetic Recording (SMR) HDDs</a>
</li>

        
            
<li >
    <a href="../../introduction/zns/">Zoned Namespace (ZNS) SSDs</a>
</li>

        
    </ul>
  </li>

                        
                            
  
  
  
  <li class="dropdown-submenu">
    <a tabindex="-1" href="/getting-started/">Getting Started</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../getting-started/prerequisite/">System Prerequisite</a>
</li>

        
            
<li >
    <a href="../../getting-started/nullblk/">Getting Started with an Emulated Zoned Block Device</a>
</li>

        
            
<li >
    <a href="../../getting-started/smr-disk/">Getting Started With SMR Disks</a>
</li>

        
            
<li >
    <a href="../../getting-started/smr-emulation/">Getting Started With Emulated SMR Disks</a>
</li>

        
            
<li >
    <a href="../../getting-started/zns-emulation/">Getting Started With Emulated NVMe ZNS Devices</a>
</li>

        
    </ul>
  </li>

                        
                            
  
  
  
  <li class="dropdown-submenu active">
    <a tabindex="-1" href="/linux/">Linux Kernel Support</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../overview/">Support Overview</a>
</li>

        
            
<li >
    <a href="../config/">Kernel Configuration</a>
</li>

        
            
<li class="active">
    <a href="./">User Interface</a>
</li>

        
            
<li >
    <a href="../sched/">Write Command Ordering</a>
</li>

        
            
<li >
    <a href="../part/">Zoned Block Device Partition Support</a>
</li>

        
            
<li >
    <a href="../dm/">Device Mapper</a>
</li>

        
            
<li >
    <a href="../fs/">File Systems</a>
</li>

        
    </ul>
  </li>

                        
                            
  
  
  
  <li class="dropdown-submenu">
    <a tabindex="-1" href="/projects/">Applications and Libraries</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../projects/util-linux/">Linux System Utilities</a>
</li>

        
            
<li >
    <a href="../../projects/sg3utils/">SCSI Generic Utilities</a>
</li>

        
            
<li >
    <a href="../../projects/libzbc/">libzbc User Library</a>
</li>

        
            
<li >
    <a href="../../projects/libnvme/">libnvme User Library</a>
</li>

        
            
<li >
    <a href="../../projects/libzbd/">libzbd User Library</a>
</li>

        
            
<li >
    <a href="../../projects/tcmu-runner/">tcmu-runner ZBC Disk Emulation</a>
</li>

        
            
<li >
    <a href="../../projects/qemu/">QEMU and KVM</a>
</li>

        
            
<li >
    <a href="../../projects/zns/">Linux Tools for ZNS</a>
</li>

        
    </ul>
  </li>

                        
                            
  
  
  
  <li class="dropdown-submenu">
    <a tabindex="-1" href="/tests/">System Compliance Tests</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../tests/zbc-tests/">ZBC/ZAC Compliance Tests</a>
</li>

        
            
<li >
    <a href="../../tests/blktests/">Kernel Block Layer Tests</a>
</li>

        
    </ul>
  </li>

                        
                            
<li >
    <a href="../../distributions/linux/">Linux Distributions</a>
</li>

                        
                            
<li >
    <a href="../../benchmarking/fio/">Benchmarking</a>
</li>

                        
                            
<li >
    <a href="../../faq/faq/">Frequently Asked Questions</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li >
                        <a href="../../about/">About</a>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../config/">
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="next" href="../sched/">
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    
    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
  <h5 style="text-align:center"><b>Table of contents</b></h5>
  <ul class="nav bs-sidenav">

  

    

      

        
        
        
          <li class="first-level"><a href="../../introduction">Introduction</a></li>
          
        

        

  	  

  	  

        

  	  

  	  

        

  	  

  	  

        

      

    

      

        
        
        
          <li class="first-level"><a href="../../getting-started">Getting Started</a></li>
          
        

        

  	  

  	  

        

  	  

  	  

        

  	  

  	  

        

  	  

  	  

        

  	  

  	  

        

      

    

      

        
        
        
          <li class="first-level active"><a href="/linux/" style="font-weight:bold">Linux Kernel Support</a></li>
          
        

        

  	  
            <li class="second-level"><a href="../overview/">Support Overview</a></li>
          

  	  

        

  	  
            <li class="second-level"><a href="../config/">Kernel Configuration</a></li>
          

  	  

        

  	  

  	  
            
              <li class="second-level active"><a href="#zoned-block-device-user-interface">Zoned Block Device User Interface</a></li>
              
                <li class="third-level"><a href="#sysfs-interface">Sysfs Interface</a></li>
                
                  <li class="fourth-level"><a href="#device-zoned-model">Device Zoned Model</a></li>
                
                  <li class="fourth-level"><a href="#device-zone-size">Device Zone Size</a></li>
                
                  <li class="fourth-level"><a href="#number-of-zones">Number of Zones</a></li>
                
              
                <li class="third-level"><a href="#ioctl-application-programming-interface">ioctl() Application Programming Interface</a></li>
                
                  <li class="fourth-level"><a href="#zone-information-data-structures">Zone Information Data Structures</a></li>
                
                  <li class="fourth-level"><a href="#zone-type">Zone Type</a></li>
                
                  <li class="fourth-level"><a href="#zone-condition">Zone Condition</a></li>
                
              
                <li class="third-level"><a href="#ioctl-commands">ioctl() Commands</a></li>
                
                  <li class="fourth-level"><a href="#obtaining-zone-information">Obtaining Zone Information</a></li>
                
                  <li class="fourth-level"><a href="#resetting-a-zone-write-pointer">Resetting a Zone Write Pointer</a></li>
                
                  <li class="fourth-level"><a href="#opening-closing-and-finishing-zones">Opening, Closing and Finishing Zones</a></li>
                
                  <li class="fourth-level"><a href="#zone-size-and-number-of-zones">Zone Size and Number of Zones</a></li>
                
              
            
          

        

  	  
            <li class="second-level"><a href="../sched/">Write Command Ordering</a></li>
          

  	  

        

  	  
            <li class="second-level"><a href="../part/">Zoned Block Device Partition Support</a></li>
          

  	  

        

  	  
            <li class="second-level"><a href="../dm/">Device Mapper</a></li>
          

  	  

        

  	  
            <li class="second-level"><a href="../fs/">File Systems</a></li>
          

  	  

        

      

    

      

        
        
        
          <li class="first-level"><a href="../../projects">Applications and Libraries</a></li>
          
        

        

  	  

  	  

        

  	  

  	  

        

  	  

  	  

        

  	  

  	  

        

  	  

  	  

        

  	  

  	  

        

  	  

  	  

        

  	  

  	  

        

      

    

      

        
        
        
          <li class="first-level"><a href="../../tests">System Compliance Tests</a></li>
          
        

        

  	  

  	  

        

  	  

  	  

        

      

    

      

        <li class="first-level"><a href="../../distributions/linux/">Linux Distributions</a></li>

      

    

      

        <li class="first-level"><a href="../../benchmarking/fio/">Benchmarking</a></li>

      

    

      

        <li class="first-level"><a href="../../faq/faq/">Frequently Asked Questions</a></li>

      

    

  

  </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="zoned-block-device-user-interface">Zoned Block Device User Interface</h1>
<p>User applications can access zone information and manage zones of a zoned block
device using two types of interfaces.</p>
<ol>
<li>
<p><em>sysfs</em> attribute files accessible either directly from applications as
   regular files or form scripted languages (shell scripts, python, etc).</p>
</li>
<li>
<p><em>ioctl()</em> system calls suitable for use from C programs or other programming
   languages with an equivalent system call binding.</p>
</li>
</ol>
<p>The <em>sysfs</em> files and <em>ioctl()</em> commands available to applications have evolved
since the introduction of zoned block device support in Kernel 4.10. The
availability of files and commands per kernel version is detailed in the
following sections.</p>
<h2 id="sysfs-interface">Sysfs Interface</h2>
<p>Programs using script languages (e.g. bash scripts) can access a zoned device
information through <em>sysfs</em> attribute files. The attribute files provided are
shown in the following table.</p>
<p><center></p>
<table>
<thead>
<tr>
<th>File</th>
<th>Kernel version</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>/sys/block/<em>dev name</em>/queue/zoned</td>
<td>4.10.0</td>
<td>Device zoned model</td>
</tr>
<tr>
<td>/sys/block/<em>dev name</em>/queue/chunk_sectors</td>
<td>4.10.0</td>
<td>Device zone size</td>
</tr>
<tr>
<td>/sys/block/<em>dev name</em>/queue/nr_zones</td>
<td>4.20.0</td>
<td>Total number of zones</td>
</tr>
<tr>
<td>/sys/block/<em>dev name</em>/queue/zone_append_max_bytes</td>
<td>5.8.0</td>
<td>Maximum size in bytes of a zone append write operation</td>
</tr>
<tr>
<td>/sys/block/<em>dev name</em>/queue/max_open_zones</td>
<td>5.9.0</td>
<td>Maximum number of open zones</td>
</tr>
<tr>
<td>/sys/block/<em>dev name</em>/queue/max_active_zones</td>
<td>5.9.0</td>
<td>Maximum number of active zones</td>
</tr>
</tbody>
</table>
<p></center></p>
<h3 id="device-zoned-model">Device Zoned Model</h3>
<p>The zone model of a zoned device can be discovered using the <code>zoned</code> device
queue attribute file. For instance, for a zoned block device named <em>sdb</em>, the
following shell command displays the device zoned model.</p>
<pre><code class="language-plaintext"># cat /sys/block/sdb/queue/zoned
host-managed
</code></pre>
<p>The possible values of the <em>zoned</em> attribute file are shown in the table below.</p>
<p><center></p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>Regular block device, including drive managed SMR disks</td>
</tr>
<tr>
<td>host-aware</td>
<td>Host aware device model</td>
</tr>
<tr>
<td>host-managed</td>
<td>Host managed device model</td>
</tr>
</tbody>
</table>
<p></center></p>
<h3 id="device-zone-size">Device Zone Size</h3>
<p>The device zone size can be read from the <em>sysfs</em> queue attribute file named
<code>chunk_sectors</code>. For the same device named <em>sdb</em> as in the previous example, the
following command gives the device zone size.</p>
<pre><code class="language-plaintext"># cat /sys/block/sdb/queue/chunk_sectors
524288
</code></pre>
<p>The value is displayed as a number of 512B sectors, regardless of the actual
logical and physical block size of the device. In this example, the device zone
size is <em>524288 x 512 = 256 MiB</em>.</p>
<h3 id="number-of-zones">Number of Zones</h3>
<p>Starting with Linux kernel version 4.20.0, the sysfs queue attribute file
<em>nr_zones</em> is available to obtain the total number of zones of a zoned device.</p>
<pre><code class="language-plaintext"># cat /sys/block/sdb/queue/nr_zones
55880
</code></pre>
<p>This attribute value is always 0 for a regular block device.</p>
<h2 id="ioctl-application-programming-interface"><em>ioctl()</em> Application Programming Interface</h2>
<p>The C header file <code>/usr/include/linux/blkzoned.h</code> contains macro definitions and
data structure definitions allowing an application developer to obtain
information on a zoned block device and to manage the zones of the device.</p>
<h3 id="zone-information-data-structures">Zone Information Data Structures</h3>
<p>The data structure <code>struct blk_zone</code> defines a zone descriptor structure which
completely describes a zone information: the zone location on the device, the
zone type, its condition (state), and the position of the zone write pointer
for sequential zones. Up to kernel version 5.8, this data structure is as shown
below.</p>
<pre><code class="language-c">/**
 * struct blk_zone - Zone descriptor for BLKREPORTZONE ioctl.
 *
 * @start: Zone start in 512 B sector units
 * @len: Zone length in 512 B sector units
 * @wp: Zone write pointer location in 512 B sector units
 * @type: see enum blk_zone_type for possible values
 * @cond: see enum blk_zone_cond for possible values
 * @non_seq: Flag indicating that the zone is using non-sequential resources
 *           (for host-aware zoned block devices only).
 * @reset: Flag indicating that a zone reset is recommended.
 * @reserved: Padding to 64 B to match the ZBC/ZAC defined zone descriptor size.
 *
 * start, len, capacity and wp use the regular 512 B sector unit, regardless
 * of the device logical block size. The overall structure size is 64 B to
 * match the ZBC, ZAC and ZNS defined zone descriptor and allow support for
 * future additional zone information.
 */
struct blk_zone {
        __u64   start;          /* Zone start sector */
        __u64   len;            /* Zone length in number of sectors */
        __u64   wp;             /* Zone write pointer position */
        __u8    type;           /* Zone type */
        __u8    cond;           /* Zone condition */
        __u8    non_seq;        /* Non-sequential write resources active */
        __u8    reset;          /* Reset write pointer recommended */
        __u8    reserved[36];
};
</code></pre>
<p>As indicated in the comments to this data structure definition, the unit that
is used to indicate the zone start position, size and write pointer position is
512B sector size, regardless of the actual logical block size of the device.
Even for a device with a 4KB physical sector, the above zone descriptor fields
use a 512-byte sector size unit.</p>
<p>The <em>capacity</em> field was added to <em>struct blk_zone</em> starting from kernel
version 5.9. With this change, the data structure is as follows.</p>
<pre><code>/**
 * struct blk_zone - Zone descriptor for BLKREPORTZONE ioctl.
 *
 * @start: Zone start in 512 B sector units
 * @len: Zone length in 512 B sector units
 * @wp: Zone write pointer location in 512 B sector units
 * @type: see enum blk_zone_type for possible values
 * @cond: see enum blk_zone_cond for possible values
 * @non_seq: Flag indicating that the zone is using non-sequential resources
 *           (for host-aware zoned block devices only).
 * @reset: Flag indicating that a zone reset is recommended.
 * @resv: Padding for 8B alignment.
 * @capacity: Zone usable capacity in 512 B sector units
 * @reserved: Padding to 64 B to match the ZBC, ZAC and ZNS defined zone
 *            descriptor size.
 *
 * start, len, capacity and wp use the regular 512 B sector unit, regardless
 * of the device logical block size. The overall structure size is 64 B to
 * match the ZBC, ZAC and ZNS defined zone descriptor and allow support for
 * future additional zone information.
 */
struct blk_zone {
        __u64   start;          /* Zone start sector */
        __u64   len;            /* Zone length in number of sectors */
        __u64   wp;             /* Zone write pointer position */
        __u8    type;           /* Zone type */
        __u8    cond;           /* Zone condition */
        __u8    non_seq;        /* Non-sequential write resources active */
        __u8    reset;          /* Reset write pointer recommended */
        __u8    resv[4];
        __u64   capacity;       /* Zone capacity in number of sectors */
        __u8    reserved[24];
};
</code></pre>
<p>The <em>capacity</em> filed indicate the usable zone capacity of a zone in unit of 512B
sectors. The presence, or validity, of this field within the structure is
indicated using a zone report flag.
See <a href="#obtaining-zone-information"><em>Obtaining Zone Information</em></a> below for
details.</p>
<h3 id="zone-type">Zone Type</h3>
<p>The <code>type</code> field of a zone descriptor can only have one of the values defined by
the enumeration <code>enum blk_zone_type</code>.</p>
<pre><code class="language-c">/**
 * enum blk_zone_type - Types of zones allowed in a zoned device.
 *
 * @BLK_ZONE_TYPE_CONVENTIONAL: The zone has no write pointer and can be writen
 *                              randomly. Zone reset has no effect on the zone.
 * @BLK_ZONE_TYPE_SEQWRITE_REQ: The zone must be written sequentially
 * @BLK_ZONE_TYPE_SEQWRITE_PREF: The zone can be written non-sequentially
 *
 * Any other value not defined is reserved and must be considered as invalid.
 */
enum blk_zone_type {
        BLK_ZONE_TYPE_CONVENTIONAL      = 0x1,
        BLK_ZONE_TYPE_SEQWRITE_REQ      = 0x2,
        BLK_ZONE_TYPE_SEQWRITE_PREF     = 0x3,
};
</code></pre>
<h3 id="zone-condition">Zone Condition</h3>
<p>The <code>cond</code> field of the <code>struct blkzone</code> data structure defines the current
condition of a zone. The possible condition (state) values of this field are
defined by the <code>blk_zone_cond</code> enumeration.</p>
<pre><code class="language-c">/**
 * enum blk_zone_cond - Condition [state] of a zone in a zoned device.
 *
 * @BLK_ZONE_COND_NOT_WP: The zone has no write pointer, it is conventional.
 * @BLK_ZONE_COND_EMPTY: The zone is empty.
 * @BLK_ZONE_COND_IMP_OPEN: The zone is open, but not explicitly opened.
 * @BLK_ZONE_COND_EXP_OPEN: The zones was explicitly opened by an
 *                          OPEN ZONE command.
 * @BLK_ZONE_COND_CLOSED: The zone was [explicitly] closed after writing.
 * @BLK_ZONE_COND_FULL: The zone is marked as full, possibly by a zone
 *                      FINISH ZONE command.
 * @BLK_ZONE_COND_READONLY: The zone is read-only.
 * @BLK_ZONE_COND_OFFLINE: The zone is offline (sectors cannot be read/written).
 *
 * The Zone Condition state machine in the ZBC/ZAC standards maps the above
 * deinitions as:
 *   - ZC1: Empty         | BLK_ZONE_EMPTY
 *   - ZC2: Implicit Open | BLK_ZONE_COND_IMP_OPEN
 *   - ZC3: Explicit Open | BLK_ZONE_COND_EXP_OPEN
 *   - ZC4: Closed        | BLK_ZONE_CLOSED
 *   - ZC5: Full          | BLK_ZONE_FULL
 *   - ZC6: Read Only     | BLK_ZONE_READONLY
 *   - ZC7: Offline       | BLK_ZONE_OFFLINE
 *
 * Conditions 0x5 to 0xC are reserved by the current ZBC/ZAC spec and should
 * be considered invalid.
 */
enum blk_zone_cond {
        BLK_ZONE_COND_NOT_WP    = 0x0,
        BLK_ZONE_COND_EMPTY     = 0x1,
        BLK_ZONE_COND_IMP_OPEN  = 0x2,
        BLK_ZONE_COND_EXP_OPEN  = 0x3,
        BLK_ZONE_COND_CLOSED    = 0x4,
        BLK_ZONE_COND_READONLY  = 0xD,
        BLK_ZONE_COND_FULL      = 0xE,
        BLK_ZONE_COND_OFFLINE   = 0xF,
};
</code></pre>
<p>Under a device normal operation, some of the conditions defined cannot result
directly from a host initiated operation. These conditions are
<code>BLK_ZONE_COND_OFFLINE</code> and <code>BLK_ZONE_COND_READONLY</code> and can only be set by the
device itself to indicate zones with capabilities limited by a hardware defect.</p>
<p>The condition <code>BLK_ZONE_COND_EXP_OPEN</code>, or <em>explicit open</em>, is the result of a
successful execution of an <code>OPEN ZONE</code> command
(see <a href="../../introduction/smr/#zone-block-commands">Zone Block Commands</a>.</p>
<p>Since the <code>OPEN ZONE</code> command is not supported by the kernel ZBD interface, a
zone can be transitioned in the <em>explicit open</em> zone condition only by using
direct device access, that is, issuing the SCSI <code>OPEN ZONE</code> command through the
<em>SG_IO</em> interface (using <em>libzbc</em>, <em>libzbc zbc_open_zone</em> utility or the
<em>sg_zone</em> utility).</p>
<h2 id="ioctl-commands"><em>ioctl()</em> Commands</h2>
<p>Several <em>ioctl()</em> commands are defined to manipulate obtain information and
manipulate zones of a zoned block device. All commands supported are shown
below.</p>
<pre><code class="language-c">/**
 * Zoned block device ioctl's:
 *
 * @BLKREPORTZONE: Get zone information. Takes a zone report as argument.
 *                 The zone report will start from the zone containing the
 *                 sector specified in the report request structure.
 * @BLKRESETZONE: Reset the write pointer of the zones in the specified
 *                sector range. The sector range must be zone aligned.
 * @BLKGETZONESZ: Get the device zone size in number of 512 B sectors.
 * @BLKGETNRZONES: Get the total number of zones of the device.
 * @BLKOPENZONE: Open the zones in the specified sector range.
 *               The 512 B sector range must be zone aligned.
 * @BLKCLOSEZONE: Close the zones in the specified sector range.
 *                The 512 B sector range must be zone aligned.
 * @BLKFINISHZONE: Mark the zones as full in the specified sector range.
 *                 The 512 B sector range must be zone aligned.
 */
#define BLKREPORTZONE   _IOWR(0x12, 130, struct blk_zone_report)
#define BLKRESETZONE    _IOW(0x12, 131, struct blk_zone_range)
#define BLKGETZONESZ    _IOR(0x12, 132, __u32)
#define BLKGETNRZONES   _IOR(0x12, 133, __u32)
#define BLKOPENZONE     _IOW(0x12, 134, struct blk_zone_range)
#define BLKCLOSEZONE    _IOW(0x12, 135, struct blk_zone_range)
#define BLKFINISHZONE   _IOW(0x12, 136, struct blk_zone_range)
</code></pre>
<p>Not all commands are available on all kernel versions. The following table shows
the kernel version that introduced each command.</p>
<p><center></p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Kernel version</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLKREPORTZONE</td>
<td>4.10.0</td>
<td>Get zone information</td>
</tr>
<tr>
<td>BLKRESETZONE</td>
<td>4.10.0</td>
<td>Reset a zone write pointer</td>
</tr>
<tr>
<td>BLKGETZONESZ</td>
<td>4.20.0</td>
<td>Get a device zone size</td>
</tr>
<tr>
<td>BLKGETNRZONES</td>
<td>4.20.0</td>
<td>Get the total number of zones of a device</td>
</tr>
<tr>
<td>BLKOPENZONE</td>
<td>5.5.0</td>
<td>Explicitly open a zone</td>
</tr>
<tr>
<td>BLKCLOSEZONE</td>
<td>5.5.0</td>
<td>Close a zone</td>
</tr>
<tr>
<td>BLKFINISHZONE</td>
<td>5.5.0</td>
<td>Finish a zone</td>
</tr>
</tbody>
</table>
<p></center></p>
<h3 id="obtaining-zone-information">Obtaining Zone Information</h3>
<p>The <em>BLKREPORTZONE</em> command allows an application to obtain a device zone
information in the form of an array of zone descriptors. The data argument
passed to the <code>ioctl()</code> must be the address of a memory area large enough to
store one <code>struct blk_zone_report</code> header structure followed by an array of
zone descriptors.</p>
<p>The zone report header structure <code>blk_zone_report</code> is as shown below.</p>
<pre><code class="language-c">/**
 * struct blk_zone_report - BLKREPORTZONE ioctl request/reply
 *
 * @sector: starting sector of report
 * @nr_zones: IN maximum / OUT actual
 * @reserved: padding to 16 byte alignment
 * @zones: Space to hold @nr_zones @zones entries on reply.
 *
 * The array of at most @nr_zones must follow this structure in memory.
 */
struct blk_zone_report {
    __u64       sector;
    __u32       nr_zones;
    __u8        reserved[4];
    struct blk_zone zones[0];
};
</code></pre>
<p>The header indicates the 512-byte sector from which the report should start and
the number of zone descriptors in the array following the header. A typical use
of the <code>BLKREPORTZONE</code> command to obtain information on all the zones of a
device is as shown below.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;linux/blkzoned.h&gt;

unsigned long long start_sector = 0;
struct blk_zone_report *hdr;
size_t hdr_len;
int nr_zones = 256;

hdr_len = sizeof(struct blk_zone_report) + nr_zones * sizeof(struct blkzone);
hdr = malloc(hdr_len);
if (!hdr)
    return -1;

while (1) {
    hdr-&gt;sector = start_sector;
    hdr-&gt;nr_zones = nr_zones;

    ret = ioctl(fd, BLKREPORTZONE, hdr);
    if (ret)
        goto error;

    if (!hdr-&gt;nr_zones) {
        /* Done */
        break;
    }

    printf(&quot;Got %u zone descriptors\n&quot;, hdr-&gt;nr_zones);
    ...

    /* The next report must start after the last zone reported */
    start_sector = hdr-&gt;zones[hdr-&gt;nr_zones - 1].start +
               hdr-&gt;zones[hdr-&gt;nr_zones - 1].len;
}
</code></pre>
<p>The number of zone descriptors obtained is returned to the user using the
<code>nr_zones</code> field of the report header structure <code>blk_zone_report</code>.</p>
<p>With the introduction of zone capacity support for NVMe Zoned Namepsaces in
kernel version 5.9, zone descriptors gained the <code>capacity</code> field. The presence
of this field is indicated using the new <code>flag</code> field added to
<code>struct blk_zone_report</code></p>
<pre><code class="language-c">/**
 * enum blk_zone_report_flags - Feature flags of reported zone descriptors.
 *
 * @BLK_ZONE_REP_CAPACITY: Zone descriptor has capacity field.
 */
enum blk_zone_report_flags {
        BLK_ZONE_REP_CAPACITY   = (1 &lt;&lt; 0),
};

/**
 * struct blk_zone_report - BLKREPORTZONE ioctl request/reply
 *
 * @sector: starting sector of report
 * @nr_zones: IN maximum / OUT actual
 * @flags: one or more flags as defined by enum blk_zone_report_flags.
 * @zones: Space to hold @nr_zones @zones entries on reply.
 *
 * The array of at most @nr_zones must follow this structure in memory.
 */
struct blk_zone_report {
    __u64       sector;
    __u32       nr_zones;
    __u32       flags;
    struct blk_zone zones[0];
};
</code></pre>
<p>If the <code>flags</code> field of <code>struct blk_zone_report</code> has the flag
<code>BLK_ZONE_REP_CAPACITY</code> set, then zone descriptors structure will have a valid
value set in the <code>capacity</code> field of <code>sturct blk_zone</code>. Otherwise, this field
can be ignored as it will always indicate a value of 0.</p>
<p>The example code below, extracted from the code of the
<a href="../../projects/libzbd/"><em>libzbd</em></a> library, illustrates how application can
implement backward compatible support for zone capacity information using the
autotools build environment.</p>
<pre><code># less configure.ac
...
AC_CHECK_HEADER(linux/blkzoned.h, [],
                [AC_MSG_ERROR([Couldn't find linux/blkzoned.h. Kernel too old ?])],
                [[#include &lt;linux/blkzoned.h&gt;]])

AC_CHECK_MEMBER([struct blk_zone.capacity],
                [AC_DEFINE(HAVE_BLK_ZONE_REP_V2, [1], [report zones includes zone capacity])],
                [], [[#include &lt;linux/blkzoned.h&gt;]])
...

# less lib/zbd.h
...
/*
 * Handle kernel zone capacity support
 */
#ifndef HAVE_BLK_ZONE_REP_V2
#define BLK_ZONE_REP_CAPACITY   (1 &lt;&lt; 0)

struct blk_zone_v2 {
        __u64   start;          /* Zone start sector */
        __u64   len;            /* Zone length in number of sectors */
        __u64   wp;             /* Zone write pointer position */
        __u8    type;           /* Zone type */
        __u8    cond;           /* Zone condition */
        __u8    non_seq;        /* Non-sequential write resources active */
        __u8    reset;          /* Reset write pointer recommended */
        __u8    resv[4];
        __u64   capacity;       /* Zone capacity in number of sectors */
        __u8    reserved[24];
};
#define blk_zone blk_zone_v2

struct blk_zone_report_v2 {
        __u64   sector;
        __u32   nr_zones;
        __u32   flags;
struct blk_zone zones[0];
};
#define blk_zone_report blk_zone_report_v2
#endif /* HAVE_BLK_ZONE_REP_V2 */
...
</code></pre>
<p>With this method, the main code responsible for issuing and parsing zone reports
always has access to the <code>capacity</code> field of <code>struct blk_zone</code>, regardless of
the kernel version the code is executed on. For kernels preceding kernel version
5.9, the zone capacity field will always be equal to 0, meaning that the zone
capacity should be ignored and the zone size used in place. Different coding
techniques can also be used to always return a zone capacity equal to the zone
size for kernels lacking support for this field.</p>
<p>The command line utility <a href="../../projects/util-linux/#blkzone"><code>blkzone</code></a>, part
of the <em>util-linux</em> project, uses the <em>BLKREPORTZONE</em> command to implement its
<em>report</em> function. Its code was modified similarly to the above method to allow
its correct compilation and execution regardless of the version of the kernel
being used.</p>
<h3 id="resetting-a-zone-write-pointer">Resetting a Zone Write Pointer</h3>
<p>The write pointer of a single sequential zone or of a range of contiguous
sequential zones can be reset using the <code>BLKRESETZONE</code> command. Resetting a
sequential zone write pointer position will also transition the zone to the
<em>Empty</em> condition (<code>BLK_ZONE_COND_EMPTY</code>).</p>
<p>The range of zones to reset is defined using the data structure <code>blk_zone_range</code>
shown below.</p>
<pre><code class="language-c">/**
 * struct blk_zone_range - BLKRESETZONE/BLKOPENZONE/
 *                         BLKCLOSEZONE/BLKFINISHZONE ioctl
 *                         requests
 * @sector: Starting sector of the first zone to operate on.
 * @nr_sectors: Total number of sectors of all zones to operate on.
 */
struct blk_zone_range {
        __u64           sector;
        __u64           nr_sectors;
};
</code></pre>
<p>The <code>sector</code> field must specify the start sector of the first zone to reset. The
<code>nr_sectors</code> field specifies the total length of the range of zones to reset.
This length must be at least as large as one zone.</p>
<p>As indicated in comments describing the <code>blk_zone_range</code> structure, the commands
<code>BLKOPENZONE</code>, <code>BLKCLOSEZONE</code> and <code>BLKFINISHZONE</code> also use this data structure
to define the range of zones on which the command will operate.</p>
<p>The following code shows an example use of the <code>BLKRESETZONE</code> command to reset a
single zone starting at sector 274726912 with a zone size of 256 MiB (524288
sectors of 512B).</p>
<pre><code class="language-c">#include &lt;linux/blkzoned.h&gt;

struct blk_zone_range zrange;
int ret;

zrange.sector = 274726912;
zrange.nr_sectors = 524288;

ret = ioctl(fd, BLKRESETZONE, &amp;zrange);
if (ret)
    goto error;
...
</code></pre>
<p>The device file descriptor <code>fd</code> must be open for writing for this command to
succeed.</p>
<p>The  command line utility <a href="../../projects/util-linux/#blkzone"><code>blkzone</code></a> uses
the <em>BLKRESETZONE</em> command to implement its <em>reset</em> functionality.</p>
<h3 id="opening-closing-and-finishing-zones">Opening, Closing and Finishing Zones</h3>
<p>Explicitely opening a zone or a range of zones can be done using the
<em>BLKOPENZONE</em> command. This command uses the same arguments as the
<em>BLKRESETZONE</em> command. It takes a pointer to a data structure <code>blk_zone_range</code>
which must specifies the range of zones to operate on.</p>
<p>Closing a zone is done using the command <em>BLKCLOSEZONE</em>. Finishing a zone, that
is transitioning the zone to the <em>full</em> condition (<code>BLK_ZONE_COND_FULL</code>), is
done using the <em>BLKFINISHZONE</em> command. Both of these commands also take as an
argument a pointer to a <code>blk_zone_range</code> data structure to specify the range of
zones to operate on.</p>
<p>The <em>BLKOPENZONE</em>, <em>BLKCLOSEZONE</em> and <em>BLKFINISHZONE</em> commands were introduced
with kernel version 5.5.0.</p>
<h3 id="zone-size-and-number-of-zones">Zone Size and Number of Zones</h3>
<p>Linux&reg; kernel version 4.20 introduced two new additional commands to obtain
a zoned device zone size (<code>BLKGETZONESZ</code>) and the total number of zones of the
device (<code>BLKGETNRZONES</code>). Both commands take a pointer to an unsigned 32-bits
integer variable as argument where the zone size value or the number of zones
will be returned. The following sample C code illustrates the use of these
commands.</p>
<pre><code class="language-c">#include &lt;linux/blkzoned.h&gt;
#include &lt;stdio.h&gt;

unsigned int nr_zones, zone_size;
int ret;

ret = ioctl(fd, ,BLKGETZONESZ, &amp;zone_size);
if (ret)
    goto error;
ret = ioctl(fd, ,BLKGETNRZONES, &amp;nr_zones);
if (ret)
    goto error;

printf(&quot;Device has %u zones of %u 512-Bytes sectors\n&quot;,
       nr_zones, zone_size);
...
</code></pre>
<p>The command <code>BLKGETNRZONES</code> is especially useful to allocate an array of zone
descriptors large enough for a zone report of all zones of a device.</p></div>
        
        
    </div>
    

    <footer class="col-md-12 text-center">
        
        <span class="text-muted" style="color:hsla(0,0%,100%,.7);font-size:13px;">
	&copy; 2020 Western Digital Corporation or its affiliates. All rights reserved.<br>
        By using this site, you agree to the <a href="https://www.westerndigital.com/legal/terms-of-use"
	target="_blank" style="color:white;">Terms of Use</a> and
	<a href="https://www.westerndigital.com/legal/privacy-statement" target="_blank" style="color:white;">Privacy Statement</a>.
        All example scripts and program snippets on this site are licensed under
	<a href="https://creativecommons.org/publicdomain/zero/1.0/" target="_blank" style="color:white;">CC0 1.0 Universal</a>.<br>
	Documentation built with <a href="https://www.mkdocs.org/" target="_blank" style="color:white;">MkDocs</a> using a theme
	based on <a href="https://sourcefoundry.org/cinder/" target="_blank" style="color:white;">Cinder</a>.
        </span>
        
    </footer>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
                <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/c.min.js"></script>
                <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/bash.min.js"></script>
                <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/plaintext.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = "../.."</script>
    
    <script src="../../js/base.js"></script>
    <script src="../../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
</body>

</html>
