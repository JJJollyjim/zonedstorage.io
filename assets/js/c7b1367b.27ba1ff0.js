"use strict";(self.webpackChunkzonedstorage_io=self.webpackChunkzonedstorage_io||[]).push([[22],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return u}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=d(t),u=o,h=m["".concat(l,".").concat(u)]||m[u]||p[u]||r;return t?a.createElement(h,i(i({ref:n},c),{},{components:t})):a.createElement(h,i({ref:n},c))}));function u(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var d=2;d<r;d++)i[d]=t[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7474:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return p}});var a=t(3117),o=t(102),r=(t(7294),t(3905)),i=["components"],s={id:"zbd-api",title:"Zoned Block Device User Interface",sidebar_label:"Zoned Block Device User Interface"},l="Zoned Block Device User Interface",d={unversionedId:"linux/zbd-api",id:"linux/zbd-api",title:"Zoned Block Device User Interface",description:"User applications can use two types of interfaces to access the zone",source:"@site/docs/linux/zbd-api.md",sourceDirName:"linux",slug:"/linux/zbd-api",permalink:"/docs/linux/zbd-api",tags:[],version:"current",frontMatter:{id:"zbd-api",title:"Zoned Block Device User Interface",sidebar_label:"Zoned Block Device User Interface"},sidebar:"docs",previous:{title:"Kernel Configuration",permalink:"/docs/linux/config"},next:{title:"Write Ordering Control",permalink:"/docs/linux/sched"}},c={},p=[{value:"Sysfs Interface",id:"sysfs-interface",level:2},{value:"Device Zoned Model",id:"device-zoned-model",level:3},{value:"Zone Size",id:"zone-size",level:3},{value:"Number of Zones",id:"number-of-zones",level:3},{value:"Zone Resources",id:"zone-resources",level:3},{value:"<em>ioctl()</em> Application Programming Interface",id:"ioctl-application-programming-interface",level:2},{value:"Zone Information Data Structures",id:"zone-information-data-structures",level:3},{value:"Zone Type",id:"zone-type",level:3},{value:"Zone Condition",id:"zone-condition",level:3},{value:"<em>ioctl()</em> Commands",id:"ioctl-commands",level:2},{value:"Obtaining Zone Information",id:"obtaining-zone-information",level:3},{value:"Resetting a Zone Write Pointer",id:"resetting-a-zone-write-pointer",level:3},{value:"Opening, Closing and Finishing Zones",id:"opening-closing-and-finishing-zones",level:3},{value:"Zone Size and Number of Zones",id:"zone-size-and-number-of-zones",level:3}],m={toc:p};function u(e){var n=e.components,t=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"zoned-block-device-user-interface"},"Zoned Block Device User Interface"),(0,r.kt)("p",null,"User applications can use two types of interfaces to access the zone\ninformation of zoned block devices and to manage the zones of zoned block\ndevices. These two types of interfaces are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"sysfs")," attribute files, which are accessible either directly from\napplications as regular files or from scripted languages (shell scripts,\npython, etc).")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"ioctl()")," system calls, which are suitable for use from C programs or other\nprogramming languages that have an equivalent system-call binding."))),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"sysfs")," files and ",(0,r.kt)("em",{parentName:"p"},"ioctl()")," commands that are available to applications\nhave evolved since the introduction of zoned block device support in Kernel\n4.10. The availability of files and commands per kernel version is detailed in\nthe following sections."),(0,r.kt)("h2",{id:"sysfs-interface"},"Sysfs Interface"),(0,r.kt)("p",null,"Programs that use scripting languages (e.g. bash scripts) can access zoned\ndevice information through ",(0,r.kt)("em",{parentName:"p"},"sysfs")," attribute files. These attribute files\nare shown in the following table."),(0,r.kt)("center",null,(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"File"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Kernel version"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"/sys/block/",(0,r.kt)("em",{parentName:"td"},"dev name"),"/queue/zoned"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4.10.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Device zoned model")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"/sys/block/",(0,r.kt)("em",{parentName:"td"},"dev name"),"/queue/chunk_sectors"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4.10.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Device zone size")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"/sys/block/",(0,r.kt)("em",{parentName:"td"},"dev name"),"/queue/nr_zones"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4.20.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Total number of zones")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"/sys/block/",(0,r.kt)("em",{parentName:"td"},"dev name"),"/queue/zone_append_max_bytes"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5.8.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Maximum size in bytes of a zone append write operation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"/sys/block/",(0,r.kt)("em",{parentName:"td"},"dev name"),"/queue/max_open_zones"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5.9.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Maximum number of open zones")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"/sys/block/",(0,r.kt)("em",{parentName:"td"},"dev name"),"/queue/max_active_zones"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5.9.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Maximum number of active zones"))))),(0,r.kt)("h3",{id:"device-zoned-model"},"Device Zoned Model"),(0,r.kt)("p",null,"The zone model of a zoned device can be discovered by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"zoned")," device\nqueue attribute file. For example: for a zoned block device named ",(0,r.kt)("em",{parentName:"p"},"sdb"),", the\nfollowing shell command displays the device zoned model."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plaintext"},"# cat /sys/block/sdb/queue/zoned\nhost-managed\n")),(0,r.kt)("p",null,"The possible values of the ",(0,r.kt)("em",{parentName:"p"},"zoned")," attribute file are shown in the table below."),(0,r.kt)("center",null,(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Value"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"none"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Regular block device, including drive-managed SMR disks")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"host-aware"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Host-aware device model")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"host-managed"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Host-managed device model"))))),(0,r.kt)("h3",{id:"zone-size"},"Zone Size"),(0,r.kt)("p",null,"The device zone size can be read from the ",(0,r.kt)("em",{parentName:"p"},"sysfs")," queue attribute file that is\nnamed ",(0,r.kt)("inlineCode",{parentName:"p"},"chunk_sectors"),". For a device named ",(0,r.kt)("em",{parentName:"p"},"sdb")," (the same device as in the\nprevious example), the following command gives the device zone size."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plaintext"},"# cat /sys/block/sdb/queue/chunk_sectors\n524288\n")),(0,r.kt)("p",null,"The value is displayed as a number of 512B sectors, regardless of the actual\nlogical and physical block size of the device. In this example, the device zone\nsize is ",(0,r.kt)("em",{parentName:"p"},"524288 x 512 = 256 MiB"),"."),(0,r.kt)("h3",{id:"number-of-zones"},"Number of Zones"),(0,r.kt)("p",null,"The sysfs queue attribute file ",(0,r.kt)("em",{parentName:"p"},"nr_zones")," was introduced in Linux kernel version\n4.20.0, and is available to obtain the total number of zones of a zoned device."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plaintext"},"# cat /sys/block/sdb/queue/nr_zones\n55880\n")),(0,r.kt)("p",null,"This attribute value is always 0 for a regular block device."),(0,r.kt)("h3",{id:"zone-resources"},"Zone Resources"),(0,r.kt)("p",null,"The device zone resources can be read from the ",(0,r.kt)("em",{parentName:"p"},"sysfs")," queue attribute files\nthat are named ",(0,r.kt)("inlineCode",{parentName:"p"},"max_open_zones")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"max_active_zones"),"."),(0,r.kt)("p",null,"For an SAS or SATA host-managed SMR disk named ",(0,r.kt)("em",{parentName:"p"},"sdb")," (the same device as in the\nprevious example), the following command gives the maximum number of zones that\ncan be in the implicit or explicit open state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plaintext"},"# cat /sys/block/sdb/queue/max_open_zones\n128\n")),(0,r.kt)("p",null,"The value is displayed as a number of zones, with 0 indicating that the device\ndoes not have any limit on the maximum number of zones that can be open."),(0,r.kt)("p",null,"For the same device, the following command gives the maximum number of zones\nthat can be active (open or closed state)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plaintext"},"# cat /sys/block/sdb/queue/max_active_zones\n0\n")),(0,r.kt)("p",null,"The value is displayed as a number of zones, with 0 indicating that the device\ndoes not have any limit on the maximum number of active zones. For SMR\nhard-disks, this limit is always 0."),(0,r.kt)("p",null,"The values that are advertised by these attributes vary, depending on the\ndevice. The following shows an example with an NVMe ZNS device."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plaintext"},"# cat /sys/block/nvme0n1/queue/max_open_zones\n14\n# cat /sys/block/nvme0n1/queue/max_active_zones\n14\n")),(0,r.kt)("p",null,"When emulating a zoned device using ",(0,r.kt)("a",{parentName:"p",href:"/docs/getting-started/nullblk"},(0,r.kt)("em",{parentName:"a"},"null_blk")),",\n",(0,r.kt)("a",{parentName:"p",href:"/docs/getting-started/zns-emulation"},(0,r.kt)("em",{parentName:"a"},"QEMU"))," or\n",(0,r.kt)("a",{parentName:"p",href:"/docs/getting-started/smr-emulation"},(0,r.kt)("em",{parentName:"a"},"tcmu-runner")),", the values of these\nattributes can be manually configured to emulate different physical device\ncharacteristics."),(0,r.kt)("h2",{id:"ioctl-application-programming-interface"},(0,r.kt)("em",{parentName:"h2"},"ioctl()")," Application Programming Interface"),(0,r.kt)("p",null,"The C header file ",(0,r.kt)("inlineCode",{parentName:"p"},"/usr/include/linux/blkzoned.h")," contains macro definitions and\ndata structure definitions that allow application developers to obtain\ninformation about zoned block devices and to manage the zones of the devices."),(0,r.kt)("h3",{id:"zone-information-data-structures"},"Zone Information Data Structures"),(0,r.kt)("p",null,"The data structure ",(0,r.kt)("inlineCode",{parentName:"p"},"struct blk_zone")," defines a zone-descriptor structure that\ncontains a complete description of a zone: this includes the zone's location on\nthe device, the zone type, its condition (state), and the position of the zone\nwrite pointer (for sequential zones). For kernels Up to kernel version 5.8, this\ndata structure is as shown below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/**\n * struct blk_zone - Zone descriptor for BLKREPORTZONE ioctl.\n *\n * @start: Zone start in 512 B sector units\n * @len: Zone length in 512 B sector units\n * @wp: Zone write pointer location in 512 B sector units\n * @type: see enum blk_zone_type for possible values\n * @cond: see enum blk_zone_cond for possible values\n * @non_seq: Flag indicating that the zone is using non-sequential resources\n *           (for host-aware zoned block devices only).\n * @reset: Flag indicating that a zone reset is recommended.\n * @reserved: Padding to 64 B to match the ZBC/ZAC defined zone descriptor size.\n *\n * start, len, capacity and wp use the regular 512 B sector unit, regardless\n * of the device logical block size. The overall structure size is 64 B to\n * match the size of the ZBC-, ZAC- and ZNS-defined zone descriptor and to \n * allow support for future additional zone information.\n */\nstruct blk_zone {\n        __u64   start;          /* Zone start sector */\n        __u64   len;            /* Zone length in number of sectors */\n        __u64   wp;             /* Zone write pointer position */\n        __u8    type;           /* Zone type */\n        __u8    cond;           /* Zone condition */\n        __u8    non_seq;        /* Non-sequential write resources active */\n        __u8    reset;          /* Reset write pointer recommended */\n        __u8    reserved[36];\n};\n")),(0,r.kt)("p",null,'As indicated in the comments on this data structure definition, the unit that\nis used to indicate (1) the zone start position, (2) the zone\'s size and (3) the\nwrite pointer position is "512B sector size". This holds true regardless of the\nactual logical block size of the device. Even for a device with a 4KB logical\nsector, the above zone descriptor fields use a 512-byte sector size unit.'),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"capacity")," field was added to ",(0,r.kt)("em",{parentName:"p"},"struct blk_zone")," in kernel version 5.9. In\nkernel versions 5.9 and later (which contain the ",(0,r.kt)("em",{parentName:"p"},"capacity")," field), the data\nstructure is as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/**\n * struct blk_zone - Zone descriptor for BLKREPORTZONE ioctl.\n *\n * @start: Zone start in 512 B sector units\n * @len: Zone length in 512 B sector units\n * @wp: Zone write pointer location in 512 B sector units\n * @type: see enum blk_zone_type for possible values\n * @cond: see enum blk_zone_cond for possible values\n * @non_seq: Flag indicating that the zone is using non-sequential resources\n *           (for host-aware zoned block devices only).\n * @reset: Flag indicating that a zone reset is recommended.\n * @resv: Padding for 8B alignment.\n * @capacity: Zone usable capacity in 512 B sector units\n * @reserved: Padding to 64 B to match the ZBC, ZAC and ZNS defined zone\n *            descriptor size.\n *\n * start, len, capacity and wp use the regular 512 B sector unit, regardless\n * of the device logical block size. The overall structure size is 64 B to\n * match the ZBC, ZAC and ZNS defined zone descriptor and allow support for\n * future additional zone information.\n */\nstruct blk_zone {\n        __u64   start;          /* Zone start sector */\n        __u64   len;            /* Zone length in number of sectors */\n        __u64   wp;             /* Zone write pointer position */\n        __u8    type;           /* Zone type */\n        __u8    cond;           /* Zone condition */\n        __u8    non_seq;        /* Non-sequential write resources active */\n        __u8    reset;          /* Reset write pointer recommended */\n        __u8    resv[4];\n        __u64   capacity;       /* Zone capacity in number of sectors */\n        __u8    reserved[24];\n};\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"capacity")," field indicates the usable zone capacity of a zone in units of\n512B sectors. The presence, or validity, of this field within the structure is\nindicated using a zone report flag.\nSee ",(0,r.kt)("a",{parentName:"p",href:"#obtaining-zone-information"},(0,r.kt)("em",{parentName:"a"},"Obtaining Zone Information"))," below for\ndetails."),(0,r.kt)("h3",{id:"zone-type"},"Zone Type"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," field of a zone descriptor can have only one of the values defined by\nthe enumeration ",(0,r.kt)("inlineCode",{parentName:"p"},"enum blk_zone_type"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/**\n * enum blk_zone_type - Types of zones allowed in a zoned device.\n *\n * @BLK_ZONE_TYPE_CONVENTIONAL: The zone has no write pointer and can be writen\n *                              randomly. Zone reset has no effect on the zone.\n * @BLK_ZONE_TYPE_SEQWRITE_REQ: The zone must be written sequentially\n * @BLK_ZONE_TYPE_SEQWRITE_PREF: The zone can be written non-sequentially\n *\n * Any other value not defined is reserved and must be considered as invalid.\n */\nenum blk_zone_type {\n        BLK_ZONE_TYPE_CONVENTIONAL      = 0x1,\n        BLK_ZONE_TYPE_SEQWRITE_REQ      = 0x2,\n        BLK_ZONE_TYPE_SEQWRITE_PREF     = 0x3,\n};\n")),(0,r.kt)("h3",{id:"zone-condition"},"Zone Condition"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"cond")," field of the ",(0,r.kt)("inlineCode",{parentName:"p"},"struct blkzone")," data structure defines the current\ncondition of a zone. The possible condition (state) values of this field are\ndefined by the ",(0,r.kt)("inlineCode",{parentName:"p"},"blk_zone_cond")," enumeration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/**\n * enum blk_zone_cond - Condition [state] of a zone in a zoned device.\n *\n * @BLK_ZONE_COND_NOT_WP: The zone has no write pointer, it is conventional.\n * @BLK_ZONE_COND_EMPTY: The zone is empty.\n * @BLK_ZONE_COND_IMP_OPEN: The zone is open, but not explicitly opened.\n * @BLK_ZONE_COND_EXP_OPEN: The zones was explicitly opened by an\n *                          OPEN ZONE command.\n * @BLK_ZONE_COND_CLOSED: The zone was [explicitly] closed after writing.\n * @BLK_ZONE_COND_FULL: The zone is marked as full, possibly by a zone\n *                      FINISH ZONE command.\n * @BLK_ZONE_COND_READONLY: The zone is read-only.\n * @BLK_ZONE_COND_OFFLINE: The zone is offline (sectors cannot be read/written).\n *\n * The Zone Condition state machine in the ZBC/ZAC standards maps the above\n * deinitions as:\n *   - ZC1: Empty         | BLK_ZONE_EMPTY\n *   - ZC2: Implicit Open | BLK_ZONE_COND_IMP_OPEN\n *   - ZC3: Explicit Open | BLK_ZONE_COND_EXP_OPEN\n *   - ZC4: Closed        | BLK_ZONE_CLOSED\n *   - ZC5: Full          | BLK_ZONE_FULL\n *   - ZC6: Read Only     | BLK_ZONE_READONLY\n *   - ZC7: Offline       | BLK_ZONE_OFFLINE\n *\n * Conditions 0x5 to 0xC are reserved by the current ZBC/ZAC spec and should\n * be considered invalid.\n */\nenum blk_zone_cond {\n        BLK_ZONE_COND_NOT_WP    = 0x0,\n        BLK_ZONE_COND_EMPTY     = 0x1,\n        BLK_ZONE_COND_IMP_OPEN  = 0x2,\n        BLK_ZONE_COND_EXP_OPEN  = 0x3,\n        BLK_ZONE_COND_CLOSED    = 0x4,\n        BLK_ZONE_COND_READONLY  = 0xD,\n        BLK_ZONE_COND_FULL      = 0xE,\n        BLK_ZONE_COND_OFFLINE   = 0xF,\n};\n")),(0,r.kt)("p",null,"Under a device's normal operation, some of these conditions cannot result\ndirectly from host-initiated operations. These conditions are\n",(0,r.kt)("inlineCode",{parentName:"p"},"BLK_ZONE_COND_OFFLINE")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BLK_ZONE_COND_READONLY"),". They can be set only by\nthe device itself, and are set to indicate zones with capabilities that have\nbeen limited by a hardware defect."),(0,r.kt)("p",null,"User operations (either write operations or zone management commands) can\nresult in transitions to other conditions. Applications that use the kernel\n",(0,r.kt)("em",{parentName:"p"},"ioctl()")," interface can issue zone managment commands. See ",(0,r.kt)("a",{parentName:"p",href:"#ioctl-commands"},(0,r.kt)("em",{parentName:"a"},"ioctl()"),"\nCommands")," for more information about this."),(0,r.kt)("p",null,"The SCSI Zoned Block Command specification (ZBC), the ATA Zoned Device ATA\nCommand Set specification (ZAC) and the NVM Express Zoned Namespace Command\nSet specification (ZNS) define a zone condition state machine that governs the\npossible transitions of a zone from one condition to another depending on the\ncommands executed."),(0,r.kt)("h2",{id:"ioctl-commands"},(0,r.kt)("em",{parentName:"h2"},"ioctl()")," Commands"),(0,r.kt)("p",null,"Several ",(0,r.kt)("em",{parentName:"p"},"ioctl()")," commands are defined to manipulate and obtain information and\nmanipulate the zones of a zoned block device. All supported commands are shown\nbelow."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/**\n * Zoned block device ioctl's:\n *\n * @BLKREPORTZONE: Get zone information. Takes a zone report as argument.\n *                 The zone report will start from the zone containing the\n *                 sector specified in the report request structure.\n * @BLKRESETZONE: Reset the write pointer of the zones in the specified\n *                sector range. The sector range must be zone aligned.\n * @BLKGETZONESZ: Get the device zone size in number of 512 B sectors.\n * @BLKGETNRZONES: Get the total number of zones of the device.\n * @BLKOPENZONE: Open the zones in the specified sector range.\n *               The 512 B sector range must be zone aligned.\n * @BLKCLOSEZONE: Close the zones in the specified sector range.\n *                The 512 B sector range must be zone aligned.\n * @BLKFINISHZONE: Mark the zones as full in the specified sector range.\n *                 The 512 B sector range must be zone aligned.\n */\n#define BLKREPORTZONE   _IOWR(0x12, 130, struct blk_zone_report)\n#define BLKRESETZONE    _IOW(0x12, 131, struct blk_zone_range)\n#define BLKGETZONESZ    _IOR(0x12, 132, __u32)\n#define BLKGETNRZONES   _IOR(0x12, 133, __u32)\n#define BLKOPENZONE     _IOW(0x12, 134, struct blk_zone_range)\n#define BLKCLOSEZONE    _IOW(0x12, 135, struct blk_zone_range)\n#define BLKFINISHZONE   _IOW(0x12, 136, struct blk_zone_range)\n")),(0,r.kt)("p",null,"Not all commands are available on all kernel versions. The following table shows\nwhich kernel version introduced each command."),(0,r.kt)("center",null,(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Command"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Kernel version"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"BLKREPORTZONE"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4.10.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Get zone information")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"BLKRESETZONE"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4.10.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Reset a zone write pointer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"BLKGETZONESZ"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4.20.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Get a device zone size")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"BLKGETNRZONES"),(0,r.kt)("td",{parentName:"tr",align:"left"},"4.20.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Get the total number of zones of a device")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"BLKOPENZONE"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5.5.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Explicitly open a zone")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"BLKCLOSEZONE"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5.5.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Close a zone")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"BLKFINISHZONE"),(0,r.kt)("td",{parentName:"tr",align:"left"},"5.5.0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Finish a zone"))))),(0,r.kt)("h3",{id:"obtaining-zone-information"},"Obtaining Zone Information"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"BLKREPORTZONE")," command allows an application to obtain a device's zone\ninformation in the form of an array of zone descriptors. The data argument\nthat is passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"ioctl()")," must be the address of a memory area that is large\nenough to store one ",(0,r.kt)("inlineCode",{parentName:"p"},"struct blk_zone_report")," header structure, followed by an\narray of zone descriptors."),(0,r.kt)("p",null,"The zone report header structure ",(0,r.kt)("inlineCode",{parentName:"p"},"blk_zone_report")," is as shown below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/**\n * struct blk_zone_report - BLKREPORTZONE ioctl request/reply\n *\n * @sector: starting sector of report\n * @nr_zones: IN maximum / OUT actual\n * @reserved: padding to 16 byte alignment\n * @zones: Space to hold @nr_zones @zones entries on reply.\n *\n * The array of at most @nr_zones must follow this structure in memory.\n */\nstruct blk_zone_report {\n    __u64       sector;\n    __u32       nr_zones;\n    __u8        reserved[4];\n    struct blk_zone zones[0];\n};\n")),(0,r.kt)("p",null,"The header indicates the 512-byte sector from which the report should start as\nwell as the number of zone descriptors in the array following the header. A\ntypical use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"BLKREPORTZONE")," command to obtain information on all the\nzones of a device is as shown below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <linux/blkzoned.h>\n\nunsigned long long start_sector = 0;\nstruct blk_zone_report *hdr;\nsize_t hdr_len;\nint nr_zones = 256;\n\nhdr_len = sizeof(struct blk_zone_report) + nr_zones * sizeof(struct blkzone);\nhdr = malloc(hdr_len);\nif (!hdr)\n    return -1;\n\nwhile (1) {\n    hdr->sector = start_sector;\n    hdr->nr_zones = nr_zones;\n\n    ret = ioctl(fd, BLKREPORTZONE, hdr);\n    if (ret)\n        goto error;\n\n    if (!hdr->nr_zones) {\n        /* Done */\n        break;\n    }\n\n    printf("Got %u zone descriptors\\n", hdr->nr_zones);\n    ...\n\n    /* The next report must start after the last zone reported */\n    start_sector = hdr->zones[hdr->nr_zones - 1].start +\n               hdr->zones[hdr->nr_zones - 1].len;\n}\n')),(0,r.kt)("p",null,"The number of zone descriptors obtained is returned to the user in the\n",(0,r.kt)("inlineCode",{parentName:"p"},"nr_zones")," field of the report header structure ",(0,r.kt)("inlineCode",{parentName:"p"},"blk_zone_report"),"."),(0,r.kt)("p",null,"When zone capacity support for NVMe Zoned Namepsaces was introduced in kernel\nversion 5.9, zone descriptors gained the ",(0,r.kt)("inlineCode",{parentName:"p"},"capacity")," field. The presence of this\nfield is indicated by the new ",(0,r.kt)("inlineCode",{parentName:"p"},"flag")," field added to ",(0,r.kt)("inlineCode",{parentName:"p"},"struct blk_zone_report"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/**\n * enum blk_zone_report_flags - Feature flags of reported zone descriptors.\n *\n * @BLK_ZONE_REP_CAPACITY: Zone descriptor has capacity field.\n */\nenum blk_zone_report_flags {\n        BLK_ZONE_REP_CAPACITY   = (1 << 0),\n};\n\n/**\n * struct blk_zone_report - BLKREPORTZONE ioctl request/reply\n *\n * @sector: starting sector of report\n * @nr_zones: IN maximum / OUT actual\n * @flags: one or more flags as defined by enum blk_zone_report_flags.\n * @zones: Space to hold @nr_zones @zones entries on reply.\n *\n * The array of at most @nr_zones must follow this structure in memory.\n */\nstruct blk_zone_report {\n    __u64       sector;\n    __u32       nr_zones;\n    __u32       flags;\n    struct blk_zone zones[0];\n};\n")),(0,r.kt)("p",null,"If the ",(0,r.kt)("inlineCode",{parentName:"p"},"flags")," field of ",(0,r.kt)("inlineCode",{parentName:"p"},"struct blk_zone_report")," has the flag\n",(0,r.kt)("inlineCode",{parentName:"p"},"BLK_ZONE_REP_CAPACITY")," set, then the zone descriptor's structure will have a\nvalid value set in the ",(0,r.kt)("inlineCode",{parentName:"p"},"capacity")," field of ",(0,r.kt)("inlineCode",{parentName:"p"},"sturct blk_zone"),". Otherwise, this\nfield will show a value of 0 and can be ignored."),(0,r.kt)("p",null,"The example code below, extracted from the code of the\n",(0,r.kt)("a",{parentName:"p",href:"/docs/tools/libzbd"},(0,r.kt)("em",{parentName:"a"},"libzbd"))," library, illustrates how applications can\nimplement backward-compatible support for zone capacity information by using the\nautotools build environment."),(0,r.kt)("p",null,"First, support for the zone capacity information in a zone report can be\ndetected as follows using the kernel user API header file ",(0,r.kt)("em",{parentName:"p"},"linux/blkzoned.h"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plaintext"},"# less configure.ac\n...\nAC_CHECK_HEADER(linux/blkzoned.h, [],\n                [AC_MSG_ERROR([Couldn't find linux/blkzoned.h. Kernel too old ?])],\n                [[#include <linux/blkzoned.h>]])\n\nAC_CHECK_MEMBER([struct blk_zone.capacity],\n                [AC_DEFINE(HAVE_BLK_ZONE_REP_V2, [1], [report zones includes zone capacity])],\n                [], [[#include <linux/blkzoned.h>]])\n")),(0,r.kt)("p",null,"For kernels reporting the capacity of zones, the macro ",(0,r.kt)("em",{parentName:"p"},"HAVE_BLK_ZONE_REP_V2"),"\nwill be defined. This macro can then be used as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/*\n * Handle kernel zone capacity support\n */\n#ifndef HAVE_BLK_ZONE_REP_V2\n#define BLK_ZONE_REP_CAPACITY   (1 << 0)\n\nstruct blk_zone_v2 {\n        __u64   start;          /* Zone start sector */\n        __u64   len;            /* Zone length in number of sectors */\n        __u64   wp;             /* Zone write pointer position */\n        __u8    type;           /* Zone type */\n        __u8    cond;           /* Zone condition */\n        __u8    non_seq;        /* Non-sequential write resources active */\n        __u8    reset;          /* Reset write pointer recommended */\n        __u8    resv[4];\n        __u64   capacity;       /* Zone capacity in number of sectors */\n        __u8    reserved[24];\n};\n#define blk_zone blk_zone_v2\n\nstruct blk_zone_report_v2 {\n        __u64   sector;\n        __u32   nr_zones;\n        __u32   flags;\n    struct blk_zone zones[0];\n};\n#define blk_zone_report blk_zone_report_v2\n#endif /* HAVE_BLK_ZONE_REP_V2 */\n...\n")),(0,r.kt)("p",null,"That is, for kernels that do not support reporting zone capacity, the zone\ndescriptor data structure type ",(0,r.kt)("inlineCode",{parentName:"p"},"struct blk_zone")," is redefined to include a\ncapacity field."),(0,r.kt)("p",null,"With this method, the code that is responsible for issuing and parsing zone\nreports always has access to the ",(0,r.kt)("inlineCode",{parentName:"p"},"capacity")," field of ",(0,r.kt)("inlineCode",{parentName:"p"},"struct blk_zone"),",\nregardless of the kernel version the code is executed on. For kernels before\nkernel version 5.9, the zone capacity field is always equal to 0, which means\nthat the reported zone capacity should be ignored and that the zone size should\nbe used in its place. If your kernel lacks support for this field, you can still\nuse various coding techniques to return a zone capacity that is equal to the\nzone size."),(0,r.kt)("p",null,"Again using the source code of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/tools/libzbd"},(0,r.kt)("em",{parentName:"a"},"libzbd"))," library as an\nexample, the zone descriptors of a zone report reply can be handled as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/*\n * zbd_parse_zone - Fill a zone descriptor\n */\nstatic inline void zbd_parse_zone(struct zbd_zone *zone, struct blk_zone *blkz,\n                                  struct blk_zone_report *rep)\n{\n        zone->start = blkz->start << SECTOR_SHIFT;\n        zone->len = blkz->len << SECTOR_SHIFT;\n        if (rep->flags & BLK_ZONE_REP_CAPACITY)\n                zone->capacity = blkz->capacity << SECTOR_SHIFT;\n        else\n                zone->capacity = zone->len;\n        zone->wp = blkz->wp << SECTOR_SHIFT;\n\n        zone->type = blkz->type;\n        zone->cond = blkz->cond;\n        zone->flags = 0;\n        if (blkz->reset)\n                zone->flags |= ZBD_ZONE_RWP_RECOMMENDED;\n        if (blkz->non_seq)\n                zone->flags |= ZBD_ZONE_NON_SEQ_RESOURCES;\n}\n")),(0,r.kt)("p",null,"As shown in this example, the capacity of a zone is always initialized to the\nsize of the zone when the kernel does not report any value. Doing so, the\ncapacity of a zone is always a valid value, regardless of the kernel version."),(0,r.kt)("p",null,"The command line utility ",(0,r.kt)("a",{parentName:"p",href:"/docs/tools/util-linux#blkzone"},(0,r.kt)("inlineCode",{parentName:"a"},"blkzone")),", which\nis part of the ",(0,r.kt)("em",{parentName:"p"},"util-linux")," project, uses the ",(0,r.kt)("em",{parentName:"p"},"BLKREPORTZONE")," command to\nimplement its ",(0,r.kt)("em",{parentName:"p"},"report")," function. Its code was modified similarly to the above\nmethod to ensure its correct compilation and execution regardless of the version\nof the kernel being used."),(0,r.kt)("h3",{id:"resetting-a-zone-write-pointer"},"Resetting a Zone Write Pointer"),(0,r.kt)("p",null,"The write pointer of a single sequential zone or of a range of contiguous\nsequential zones can be reset using the ",(0,r.kt)("inlineCode",{parentName:"p"},"BLKRESETZONE")," command. Resetting a\nsequential zone write pointer position will also transition the zone to the\n",(0,r.kt)("em",{parentName:"p"},"Empty")," condition (",(0,r.kt)("inlineCode",{parentName:"p"},"BLK_ZONE_COND_EMPTY"),")."),(0,r.kt)("p",null,"The range of zones targeted for resetting is defined using the data structure\n",(0,r.kt)("inlineCode",{parentName:"p"},"blk_zone_range"),", shown below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/**\n * struct blk_zone_range - BLKRESETZONE/BLKOPENZONE/\n *                         BLKCLOSEZONE/BLKFINISHZONE ioctl\n *                         requests\n * @sector: Starting sector of the first zone to operate on.\n * @nr_sectors: Total number of sectors of all zones to operate on.\n */\nstruct blk_zone_range {\n        __u64           sector;\n        __u64           nr_sectors;\n};\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"sector")," field specifies the start sector of the first zone to reset. The\n",(0,r.kt)("inlineCode",{parentName:"p"},"nr_sectors")," field specifies the total length of the range of zones to reset.\nThis length must be at least as large as one zone."),(0,r.kt)("p",null,"As indicated in comments describing the ",(0,r.kt)("inlineCode",{parentName:"p"},"blk_zone_range")," structure, the commands\n",(0,r.kt)("inlineCode",{parentName:"p"},"BLKOPENZONE"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"BLKCLOSEZONE")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BLKFINISHZONE")," also use this data structure\nto define the range of zones on which the command operates."),(0,r.kt)("p",null,"The following code shows an example use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"BLKRESETZONE")," command to reset\na single zone that starts at sector 274726912 and has a zone size of 256 MiB\n(524288 sectors of 512B)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#include <sys/ioctl.h>\n#include <linux/blkzoned.h>\n\nstruct blk_zone_range zrange;\nint ret;\n\nzrange.sector = 274726912;\nzrange.nr_sectors = 524288;\n\nret = ioctl(fd, BLKRESETZONE, &zrange);\nif (ret)\n    goto error;\n...\n")),(0,r.kt)("p",null,"The device file descriptor ",(0,r.kt)("inlineCode",{parentName:"p"},"fd")," must be open for writing in order for this\ncommand to succeed."),(0,r.kt)("p",null,"The  command line utility ",(0,r.kt)("a",{parentName:"p",href:"/docs/tools/util-linux#blkzone"},(0,r.kt)("inlineCode",{parentName:"a"},"blkzone"))," uses\nthe ",(0,r.kt)("em",{parentName:"p"},"BLKRESETZONE")," command to implement its ",(0,r.kt)("em",{parentName:"p"},"reset")," functionality."),(0,r.kt)("h3",{id:"opening-closing-and-finishing-zones"},"Opening, Closing and Finishing Zones"),(0,r.kt)("p",null,"Explicitly opening a zone or a range of zones can be done using the\n",(0,r.kt)("em",{parentName:"p"},"BLKOPENZONE")," command. This command uses the same arguments as the\n",(0,r.kt)("em",{parentName:"p"},"BLKRESETZONE")," command. It takes a pointer to a data structure ",(0,r.kt)("inlineCode",{parentName:"p"},"blk_zone_range"),",\nwhich specifies the range of zones to operate on."),(0,r.kt)("p",null,"Closing a zone is done using the command ",(0,r.kt)("em",{parentName:"p"},"BLKCLOSEZONE"),". Finishing a zone--that\nis, transitioning the zone to the ",(0,r.kt)("em",{parentName:"p"},"full")," condition (",(0,r.kt)("inlineCode",{parentName:"p"},"BLK_ZONE_COND_FULL"),"), is\ndone using the ",(0,r.kt)("em",{parentName:"p"},"BLKFINISHZONE")," command. Both of these commands also take as\narguments a pointer to the ",(0,r.kt)("inlineCode",{parentName:"p"},"blk_zone_range")," data structure to specify the range\nof zones to operate on."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"BLKOPENZONE"),", ",(0,r.kt)("em",{parentName:"p"},"BLKCLOSEZONE")," and ",(0,r.kt)("em",{parentName:"p"},"BLKFINISHZONE")," commands were introduced\nin kernel version 5.5.0."),(0,r.kt)("h3",{id:"zone-size-and-number-of-zones"},"Zone Size and Number of Zones"),(0,r.kt)("p",null,"Linux","\xae"," kernel version 4.20 introduced two new commands: one to obtain a\nzoned device's zone size (",(0,r.kt)("inlineCode",{parentName:"p"},"BLKGETZONESZ"),"), and one to obtain the total number\nof zones of the device (",(0,r.kt)("inlineCode",{parentName:"p"},"BLKGETNRZONES"),"). Both commands take a pointer to an\nunsigned 32-bit integer variable as an argument, and both commands return the\nzone-size value or the number of zones. The following sample C code illustrates\nthe use of these commands."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <sys/ioctl.h>\n#include <linux/blkzoned.h>\n#include <stdio.h>\n\nunsigned int nr_zones, zone_size;\nint ret;\n\nret = ioctl(fd, ,BLKGETZONESZ, &zone_size);\nif (ret)\n    goto error;\nret = ioctl(fd, ,BLKGETNRZONES, &nr_zones);\nif (ret)\n    goto error;\n\nprintf("Device has %u zones of %u 512-Bytes sectors\\n",\n       nr_zones, zone_size);\n...\n')),(0,r.kt)("p",null,"The command ",(0,r.kt)("inlineCode",{parentName:"p"},"BLKGETNRZONES")," is especially useful for allocating an array of\nzone descriptors large enough for a zone report on all the zones of a device."))}u.isMDXComponent=!0}}]);