"use strict";(self.webpackChunkzonedstorage_io=self.webpackChunkzonedstorage_io||[]).push([[226],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return u}});var a=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l=a.createContext({}),d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),m=d(t),u=s,g=m["".concat(l,".").concat(u)]||m[u]||c[u]||i;return t?a.createElement(g,o(o({ref:n},p),{},{components:t})):a.createElement(g,o({ref:n},p))}));function u(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var i=t.length,o=new Array(i);o[0]=m;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r.mdxType="string"==typeof e?e:s,o[1]=r;for(var d=2;d<i;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3770:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return r},metadata:function(){return l},toc:function(){return d},default:function(){return c}});var a=t(7462),s=t(3366),i=(t(7294),t(3905)),o=["components"],r={id:"sg3utils",title:"SCSI Generic Utilities",sidebar_label:"SCSI Generic Utilities"},l={unversionedId:"tools/sg3utils",id:"tools/sg3utils",isDocsHomePage:!1,title:"SCSI Generic Utilities",description:"Various open source projects provide support for directly manipulating SCSI",source:"@site/docs/tools/sg3utils.md",sourceDirName:"tools",slug:"/tools/sg3utils",permalink:"/docs/tools/sg3utils",version:"current",sidebar_label:"SCSI Generic Utilities",frontMatter:{id:"sg3utils",title:"SCSI Generic Utilities",sidebar_label:"SCSI Generic Utilities"},sidebar:"docs",previous:{title:"ZNS Tools",permalink:"/docs/tools/zns"},next:{title:"libzbc User Library",permalink:"/docs/tools/libzbc"}},d=[{value:"lsscsi",id:"lsscsi",children:[{value:"Identifying Host Managed Disks",id:"identifying-host-managed-disks",children:[]},{value:"Disks Interface and Transport",id:"disks-interface-and-transport",children:[]}]},{value:"sg3_utils",id:"sg3_utils",children:[{value:"sg_rep_zone",id:"sg_rep_zone",children:[]},{value:"sg_reset_wp",id:"sg_reset_wp",children:[]},{value:"sg_zone",id:"sg_zone",children:[]}]}],p={toc:d};function c(e){var n=e.components,t=(0,s.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Various open source projects provide support for directly manipulating SCSI\ndevices. The ",(0,i.kt)("em",{parentName:"p"},"lsscsi")," command line tool and the ",(0,i.kt)("em",{parentName:"p"},"sg3_utils")," library and\nutilities collection are among the most widely used and they are available as\npre-compiled packages with most Linux","\xae"," distributions."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"lsscsi")," has the capability to indicate if a device is a ZBC host managed zoned\nblock device, and the ",(0,i.kt)("em",{parentName:"p"},"sg3_utils")," collection gained ZBC support with version\n1.42."),(0,i.kt)("h2",{id:"lsscsi"},"lsscsi"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{href:"http://sg.danny.cz/scsi/lsscsi.html",target:"_blank"},(0,i.kt)("em",{parentName:"p"},"lsscsi")),"\ncommand lists information about the SCSI devices connected to a Linux system.\n",(0,i.kt)("em",{parentName:"p"},"lsscsi")," is generally available as a package with most Linux distributions. For\ninstance, on ",(0,i.kt)("a",{parentName:"p",href:"/docs/distributions/linux#fedora-linux"},"Fedora","\xae")," Linux,\n",(0,i.kt)("em",{parentName:"p"},"lssci")," can be installed using the following command."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# dnf install lsscsi\n")),(0,i.kt)("p",null,"The name of the package may differ between distributions. Please refer to the\ndistribution documentation to find out the correct package name."),(0,i.kt)("h3",{id:"identifying-host-managed-disks"},"Identifying Host Managed Disks"),(0,i.kt)("p",null,"Executing ",(0,i.kt)("em",{parentName:"p"},"lsscsi")," will list the disks that are managed using the kernel SCSI\nsubsystem. This always includes SATA disks directly connected to a SATA port on\nthe system mainboard or to a SATA PCIe adapter."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# lsscsi\n[2:0:0:0]    disk    ATA      INTEL SSDSC2CT18 335u  /dev/sda\n[4:0:0:0]    zbc     ATA      HGST HSH721414AL T220  /dev/sdb\n[10:0:1:0]   zbc     HGST     HSH721414AL52M0  a220  /dev/sdc\n[10:0:3:0]   zbc     ATA      HGST HSH721415AL T220  /dev/sdd\n")),(0,i.kt)("p",null,"The second column of the default output indicates the device type. For\nhost managed disks, the type name is ",(0,i.kt)("inlineCode",{parentName:"p"},"zbc"),". For regular disks, it is ",(0,i.kt)("inlineCode",{parentName:"p"},"disk"),".\nOlder versions of lsscsi may directly list the numerical value of the device\ntype. In the case of host managed disks, the value displayed is ",(0,i.kt)("inlineCode",{parentName:"p"},"0x14"),"."),(0,i.kt)("p",null,"Adding the option ",(0,i.kt)("inlineCode",{parentName:"p"},"-g")," will output the SCSI Generic node file path associated\nwith a device. This is useful when using ",(0,i.kt)("a",{parentName:"p",href:"/docs/tools/libzbc"},"libzbc")," or any of the\n",(0,i.kt)("em",{parentName:"p"},"sg3_utils")," command line tools."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# lsscsi -g\n[2:0:0:0]    disk    ATA      INTEL SSDSC2CT18 335u  /dev/sda   /dev/sg0\n[4:0:0:0]    zbc     ATA      HGST HSH721414AL T220  /dev/sdb   /dev/sg1\n[10:0:1:0]   zbc     HGST     HSH721414AL52M0  a220  /dev/sdc   /dev/sg2\n[10:0:3:0]   zbc     ATA      HGST HSH721415AL T220  /dev/sdd   /dev/sg3\n\n")),(0,i.kt)("h3",{id:"disks-interface-and-transport"},"Disks Interface and Transport"),(0,i.kt)("p",null,"The third column of the output is the disk vendor ID. For ATA disks, this is\nalways ",(0,i.kt)("inlineCode",{parentName:"p"},"ATA")," even for ATA disks connected to a SAS host-bus-adapter (HBA). The\n",(0,i.kt)("em",{parentName:"p"},"transport")," used to communicate with the disk can be more precisely discovered\nusing the ",(0,i.kt)("inlineCode",{parentName:"p"},"-t")," option."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# lsscsi -t\n[2:0:0:0]    disk    sata:55cd2e4000111f9b           /dev/sda\n[4:0:0:0]    zbc     sata:5000cca25bc03731           /dev/sdb\n[10:0:1:0]   zbc     sas:0x5000cca0000025c5          /dev/sdc\n[10:0:3:0]   zbc     sas:0x300062b200f35d43          /dev/sdd\n")),(0,i.kt)("h2",{id:"sg3_utils"},"sg3_utils"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{href:"http://sg.danny.cz/sg/sg3_utils.html",target:"_blank"},(0,i.kt)("em",{parentName:"p"},"sg3_utils")),"\nproject provides a library and a collection of command line tools that directly\nsend SCSI commands to a SCSI device using the kernel SCSI generic driver."),(0,i.kt)("p",null,"The SCSI generic driver (",(0,i.kt)("em",{parentName:"p"},"sg")," driver) is generally enabled by default on most\ndistributions. The following command allows checking if the ",(0,i.kt)("em",{parentName:"p"},"sg")," driver module\nis already loaded."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# cat /proc/modules | grep sg\n")),(0,i.kt)("p",null,"If this command output is empty, the ",(0,i.kt)("em",{parentName:"p"},"sg")," driver should be loaded."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# modprobe sg\n")),(0,i.kt)("p",null,"These commands will work only if the ",(0,i.kt)("em",{parentName:"p"},"sg")," driver was compiled as a loadable\nkernel module. In case of error, to verify if the ",(0,i.kt)("em",{parentName:"p"},"sg")," driver was instead\ncompiled as part of the kernel, the following command can be used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# modprobe sg\nmodinfo: ERROR: Module sg not found.\n\n# cat /lib/modules/`uname -r`/modules.builtin | grep sg\nkernel/drivers/scsi/sg.ko\n")),(0,i.kt)("p",null,"Since all disks in Linux are exposed as SCSI devices, including all ATA\ndrives, these utilities can be used to manage both SCSI ZBC disks and SATA ZAC\ndisks. For SATA disks connected to SATA ports (e.g. an AHCI adapter), the\nkernel SCSI subsystem translates SCSI commands to ATA commands."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"sg3_utils")," includes three command line tools that are specific to ZBC disks."),(0,i.kt)("center",null,(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Utility Name"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Main SCSI Command Invoked"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"td"},"sg_rep_zones")),(0,i.kt)("td",{parentName:"tr",align:"left"},"REPORT ZONES"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Get a ZBC disk zone information")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"td"},"sg_reset_wp")),(0,i.kt)("td",{parentName:"tr",align:"left"},"RESET WRITE POINTER"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Reset one or all zones of a ZBC disk")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"td"},"sg_zone")),(0,i.kt)("td",{parentName:"tr",align:"left"},"CLOSE ZONE, FINISH ZONE, OPEN ZONE"),(0,i.kt)("td",{parentName:"tr",align:"left"},"Sends one of these commands to the given ZBC device"))))),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"The help output of the commands below uses the term LBA. In this\ncontext, the term LBA refers to a 512 bytes sector size regardless of\nthe logical and physical block size of the disk."))),(0,i.kt)("h3",{id:"sg_rep_zone"},"sg_rep_zone"),(0,i.kt)("p",null,"Executing the command with the ",(0,i.kt)("inlineCode",{parentName:"p"},"--help")," option gives a simple usage explanation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# sg_rep_zones --help\nUsage: sg_rep_zones  [--help] [--hex] [--maxlen=LEN] [--partial]\n                     [--raw] [--readonly] [--report=OPT] [--start=LBA]\n                     [--verbose] [--version] DEVICE\n  where:\n    --help|-h          print out usage message\n    --hex|-H           output response in hexadecimal; used twice\n                       shows decoded values in hex\n    --maxlen=LEN|-m LEN    max response length (allocation length in cdb)\n                           (def: 0 -> 8192 bytes)\n    --partial|-p       sets PARTIAL bit in cdb\n    --raw|-r           output response in binary\n    --readonly|-R      open DEVICE read-only (def: read-write)\n    --report=OPT|-o OP    reporting options (def: 0: all zones)\n    --start=LBA|-s LBA    report zones from the LBA (def: 0)\n                          need not be a zone starting LBA\n    --verbose|-v       increase verbosity\n    --version|-V       print version string and exit\n\nPerforms a SCSI REPORT ZONES command.\n")),(0,i.kt)("p",null,"Below is an example of the ",(0,i.kt)("inlineCode",{parentName:"p"},"sg_rep_zone")," utility output."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# sg_rep_zone /dev/sdd\nReport zones response:\n  Same=1: zone type and length same in each descriptor\n\n  Maximum LBA: 0xda47ffff\n Zone descriptor: 0\n   Zone type: Conventional\n   Zone condition: Not write pointer\n   Non_seq: 0\n   Reset: 0\n   Zone Length: 0x10000\n   Zone start LBA: 0x0\n   Write pointer LBA: 0xffffffffffff\n Zone descriptor: 1\n   Zone type: Conventional\n   Zone condition: Not write pointer\n   Non_seq: 0\n   Reset: 0\n   Zone Length: 0x10000\n   Zone start LBA: 0x10000\n   Write pointer LBA: 0xffffffffffff\n Zone descriptor: 2\n   Zone type: Conventional\n   Zone condition: Not write pointer\n   Non_seq: 0\n   Reset: 0\n   Zone Length: 0x10000\n   Zone start LBA: 0x20000\n   Write pointer LBA: 0xffffffffffff\n ...\n")),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"The block device file path or the device SCSI Generic node file path can\nboth be used to specify a disk."))),(0,i.kt)("p",null,"It is possible to start a zone report at a specific zone by using the\n",(0,i.kt)("inlineCode",{parentName:"p"},"--start")," option. For instance, to obtain the zone information starting at the\nfirst sequential zone of the disk (LBA 34340864), the following command\ncan be used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# sg_rep_zones --start=34340864 /dev/sdd\nReport zones response:\n  Same=1: zone type and length same in each descriptor\n\n  Maximum LBA: 0xda47ffff\n Zone descriptor: 0\n   Zone type: Sequential write required\n   Zone condition: Empty\n   Non_seq: 0\n   Reset: 0\n   Zone Length: 0x10000\n   Zone start LBA: 0x20c0000\n   Write pointer LBA: 0x20c0000\n Zone descriptor: 1\n   Zone type: Sequential write required\n   Zone condition: Empty\n   Non_seq: 0\n   Reset: 0\n   Zone Length: 0x10000\n   Zone start LBA: 0x20d0000\n   Write pointer LBA: 0x20d0000\n ...\n")),(0,i.kt)("h3",{id:"sg_reset_wp"},"sg_reset_wp"),(0,i.kt)("p",null,"The command usage is as follows."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# sg_reset_wp --help\nUsage: sg_reset_wp  [--all] [--help] [--verbose] [--version]\n                    [--zone=ID] DEVICE\n  where:\n    --all|-a           sets the ALL flag in the cdb\n    --help|-h          print out usage message\n    --verbose|-v       increase verbosity\n    --version|-V       print version string and exit\n\n    --zone=ID|-z ID    ID is the starting LBA of the zone whose\n                       write pointer is to be reset\nPerforms a SCSI RESET WRITE POINTER command. ID is decimal by default,\nfor hex use a leading '0x' or a trailing 'h'. Either the --zone=ID\nor --all option needs to be given.\n")),(0,i.kt)("p",null,"Resetting all sequential write zones of the disk can be done using the ",(0,i.kt)("inlineCode",{parentName:"p"},"--all"),"\noption."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# sg_reset_wp --all /dev/sdd\n")),(0,i.kt)("p",null,"A single sequential zone write pointer can be reset using the ",(0,i.kt)("inlineCode",{parentName:"p"},"--zone")," option."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# sg_reset_wp --zone=34340864 /dev/sdd\n")),(0,i.kt)("p",null,"Specifying the zone ID (zone start LBA) of a conventional zone results in\nan error."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# sg_reset_wp --zone=0 /dev/sdd\nReset write pointer command: Illegal request\n")),(0,i.kt)("p",null,"Reseting the write pointer of an empty sequential write zone has no effect\nand does not result in an error."),(0,i.kt)("h3",{id:"sg_zone"},"sg_zone"),(0,i.kt)("p",null,"The command usage is as follows."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# sg_zone --help\nUsage: sg_zone  [--all] [--close] [--finish] [--help] [--open]\n                [--verbose] [--version] [--zone=ID] DEVICE\n  where:\n    --all|-a           sets the ALL flag in the cdb\n    --close|-c         issue CLOSE ZONE command\n    --finish|-f        issue FINISH ZONE command\n    --help|-h          print out usage message\n    --open|-o          issue OPEN ZONE command\n    --verbose|-v       increase verbosity\n    --version|-V       print version string and exit\n    --zone=ID|-z ID    ID is the starting LBA of the zone\n\n*sg_zone* can perform OPEN ZONE, CLOSE ZONE or FINISH ZONE SCSI commands. ID is\ndecimal by default. To enter a hexadecimal value, use a leading '0x' or\na trailing 'h'. Either --close, --finish, or --open option needs to be given.\nThere is no --reset option as it would duplicate the functionality provided\nby *sg_reset_wp* utility.\n")),(0,i.kt)("p",null,"The following example command sequence illustrates ",(0,i.kt)("em",{parentName:"p"},"sg_zone")," and ",(0,i.kt)("em",{parentName:"p"},"sg_reset_wp"),"\neffects on condition of a zone as reported with ",(0,i.kt)("em",{parentName:"p"},"sg_rep_zone"),". At first, the\nbeginning sequential zone on the disk is explicitly open from empty condition.\nThen, the zone is transitioned to full condition using the zone finish command\nand, finally, reset again to return to empty condition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plaintext"},"# sg_rep_zones --start=34340864 /dev/sdd\nReport zones response:\n  Same=1: zone type and length same in each descriptor\n\n  Maximum LBA: 0xda47ffff\n Zone descriptor: 0\n   Zone type: Sequential write required\n   Zone condition: {==Empty==}\n   Non_seq: 0\n   Reset: 0\n   Zone Length: 0x10000\n   Zone start LBA: 0x20c0000\n   Write pointer LBA: 0x20c0000\n ...\n# sg_zone --open --zone=34340864 /dev/sdd\n# sg_rep_zones --start=34340864 /dev/sdd\nReport zones response:\n  Same=1: zone type and length same in each descriptor\n\n  Maximum LBA: 0xda47ffff\n Zone descriptor: 0\n   Zone type: Sequential write required\n   Zone condition: {==Explicitly opened==}\n   Non_seq: 0\n   Reset: 0\n   Zone Length: 0x10000\n   Zone start LBA: 0x20c0000\n   Write pointer LBA: 0x20c0000\n ...\n# sg_zone --finish --zone=34340864 /dev/sdd\n# sg_rep_zones --start=34340864 /dev/sdd\nReport zones response:\n  Same=1: zone type and length same in each descriptor\n\n  Maximum LBA: 0xda47ffff\n Zone descriptor: 0\n   Zone type: Sequential write required\n   Zone condition: {==Full==}\n   Non_seq: 0\n   Reset: 0\n   Zone Length: 0x10000\n   Zone start LBA: 0x20c0000\n   Write pointer LBA: 0xffffffffffff\n ...\n# sg_reset_wp --zone=34340864 /dev/sdd\n# sg_rep_zones --start=34340864 /dev/sdd\nReport zones response:\n  Same=1: zone type and length same in each descriptor\n\n  Maximum LBA: 0xda47ffff\n Zone descriptor: 0\n   Zone type: Sequential write required\n   Zone condition: {==Empty==}\n   Non_seq: 0\n   Reset: 0\n   Zone Length: 0x10000\n   Zone start LBA: 0x20c0000\n   Write pointer LBA: 0x20c0000\n ...\n")))}c.isMDXComponent=!0}}]);